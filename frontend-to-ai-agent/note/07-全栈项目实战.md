# 07 - å…¨æ ˆé¡¹ç›®å®æˆ˜

> **å‰ç½®æ¡ä»¶**ï¼šå®Œæˆå‰é¢æ‰€æœ‰é˜¶æ®µçš„å­¦ä¹   
> **å­¦ä¹ æ—¶é•¿**ï¼šæŒç»­å®è·µ  
> **å­¦ä¹ ç›®æ ‡**ï¼šæ•´åˆå‰åç«¯æŠ€æœ¯,æ„å»ºå®Œæ•´çš„ AI åº”ç”¨äº§å“

---

## ğŸ¯ å…¨æ ˆ AI åº”ç”¨æ¶æ„

### æŠ€æœ¯æ ˆæ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å‰ç«¯å±‚ (Frontend)               â”‚
â”‚     React/Vue + TypeScript + Tailwind       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ HTTP/WebSocket
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              API å±‚ (Backend)                â”‚
â”‚         FastAPI + LangChain + Python        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‘é‡æ•°æ®åº“  â”‚   â”‚   å…³ç³»å‹æ•°æ®åº“  â”‚
â”‚   Chroma     â”‚   â”‚   PostgreSQL   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              AI æœåŠ¡å±‚                       â”‚
â”‚        OpenAI API / Local LLM              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š é¡¹ç›®å®æˆ˜

### é¡¹ç›® 1ï¼šAI é©±åŠ¨çš„çŸ¥è¯†åº“é—®ç­”ç³»ç»Ÿ

#### 1.1 é¡¹ç›®éœ€æ±‚

**åŠŸèƒ½ç‰¹æ€§**ï¼š
- âœ… ç”¨æˆ·è®¤è¯ä¸æƒé™ç®¡ç†
- âœ… æ–‡æ¡£ä¸Šä¼ ï¼ˆPDFã€Wordã€TXTã€Markdownï¼‰
- âœ… æ™ºèƒ½é—®ç­”ï¼ˆRAGï¼‰
- âœ… å¤šè½®å¯¹è¯æ”¯æŒ
- âœ… å®æ—¶æµå¼å“åº”
- âœ… æ¥æºè¿½æº¯
- âœ… æœç´¢å†å²
- âœ… æ–‡æ¡£ç®¡ç†

---

#### 1.2 åç«¯å®ç°

```python
# backend/main.py
from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import List
import shutil
from pathlib import Path

from .database import engine, get_db
from .models import Base, User, Document, ChatHistory
from .schemas import UserCreate, DocumentResponse, ChatRequest
from .auth import get_current_user, create_access_token
from .rag import RAGSystem

# åˆ›å»ºæ•°æ®åº“è¡¨
Base.metadata.create_all(bind=engine)

app = FastAPI(title="AI Knowledge Base")

# CORS é…ç½®
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# åˆå§‹åŒ– RAG ç³»ç»Ÿ
rag_system = RAGSystem()

# ============= è®¤è¯ç›¸å…³ =============

@app.post("/api/auth/register")
async def register(user: UserCreate, db: Session = Depends(get_db)):
    """ç”¨æˆ·æ³¨å†Œ"""
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # åˆ›å»ºæ–°ç”¨æˆ·
    db_user = User(
        email=user.email,
        hashed_password=get_password_hash(user.password)
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    # åˆ›å»º token
    token = create_access_token(data={"sub": user.email})
    return {"access_token": token, "token_type": "bearer"}

@app.post("/api/auth/login")
async def login(email: str, password: str, db: Session = Depends(get_db)):
    """ç”¨æˆ·ç™»å½•"""
    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.hashed_password):
        raise HTTPException(status_code=401, detail="Incorrect email or password")
    
    token = create_access_token(data={"sub": user.email})
    return {"access_token": token, "token_type": "bearer"}

# ============= æ–‡æ¡£ç®¡ç† =============

@app.post("/api/documents/upload")
async def upload_document(
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ä¸Šä¼ æ–‡æ¡£"""
    # ä¿å­˜æ–‡ä»¶
    upload_dir = Path(f"./uploads/{current_user.id}")
    upload_dir.mkdir(parents=True, exist_ok=True)
    
    file_path = upload_dir / file.filename
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    # å¤„ç†æ–‡æ¡£å¹¶æ·»åŠ åˆ°å‘é‡æ•°æ®åº“
    try:
        doc_info = rag_system.add_document(
            file_path=str(file_path),
            user_id=current_user.id
        )
        
        # ä¿å­˜æ–‡æ¡£è®°å½•
        db_doc = Document(
            filename=file.filename,
            file_path=str(file_path),
            file_size=file_path.stat().st_size,
            user_id=current_user.id
        )
        db.add(db_doc)
        db.commit()
        
        return {
            "message": "Document uploaded successfully",
            "document_id": db_doc.id,
            "chunks": doc_info['chunks']
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/documents", response_model=List[DocumentResponse])
async def list_documents(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–ç”¨æˆ·çš„æ–‡æ¡£åˆ—è¡¨"""
    documents = db.query(Document).filter(Document.user_id == current_user.id).all()
    return documents

@app.delete("/api/documents/{document_id}")
async def delete_document(
    document_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """åˆ é™¤æ–‡æ¡£"""
    document = db.query(Document).filter(
        Document.id == document_id,
        Document.user_id == current_user.id
    ).first()
    
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    
    # åˆ é™¤æ–‡ä»¶å’Œæ•°æ®åº“è®°å½•
    Path(document.file_path).unlink(missing_ok=True)
    rag_system.remove_document(document_id)
    db.delete(document)
    db.commit()
    
    return {"message": "Document deleted successfully"}

# ============= å¯¹è¯ç›¸å…³ =============

@app.post("/api/chat")
async def chat(
    request: ChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """æ™®é€šé—®ç­”"""
    try:
        response = rag_system.ask(
            question=request.question,
            user_id=current_user.id,
            session_id=request.session_id
        )
        
        # ä¿å­˜å¯¹è¯å†å²
        chat_history = ChatHistory(
            user_id=current_user.id,
            session_id=request.session_id,
            question=request.question,
            answer=response['answer']
        )
        db.add(chat_history)
        db.commit()
        
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.websocket("/ws/chat/{session_id}")
async def websocket_chat(
    websocket: WebSocket,
    session_id: str,
    token: str,
    db: Session = Depends(get_db)
):
    """WebSocket å®æ—¶å¯¹è¯ï¼ˆæµå¼å“åº”ï¼‰"""
    await websocket.accept()
    
    # éªŒè¯ token
    try:
        current_user = get_current_user_from_token(token, db)
    except:
        await websocket.close(code=1008)
        return
    
    try:
        while True:
            # æ¥æ”¶æ¶ˆæ¯
            question = await websocket.receive_text()
            
            # æµå¼å“åº”
            full_answer = ""
            async for chunk in rag_system.ask_stream(
                question=question,
                user_id=current_user.id,
                session_id=session_id
            ):
                full_answer += chunk
                await websocket.send_json({
                    "type": "chunk",
                    "content": chunk
                })
            
            # å‘é€å®Œæˆä¿¡å·
            await websocket.send_json({"type": "done"})
            
            # ä¿å­˜å†å²
            chat_history = ChatHistory(
                user_id=current_user.id,
                session_id=session_id,
                question=question,
                answer=full_answer
            )
            db.add(chat_history)
            db.commit()
            
    except Exception as e:
        print(f"WebSocket error: {e}")
        await websocket.close()

@app.get("/api/chat/history/{session_id}")
async def get_chat_history(
    session_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–å¯¹è¯å†å²"""
    history = db.query(ChatHistory).filter(
        ChatHistory.user_id == current_user.id,
        ChatHistory.session_id == session_id
    ).order_by(ChatHistory.created_at).all()
    
    return history

# ============= RAG ç³»ç»Ÿå®ç° =============

# backend/rag.py
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.chains import ConversationalRetrievalChain
from langchain.memory import ConversationBufferMemory
from langchain.document_loaders import PyPDFLoader, TextLoader
from typing import AsyncGenerator
import uuid

class RAGSystem:
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4", temperature=0)
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = Chroma(
            embedding_function=self.embeddings,
            persist_directory="./vectordb"
        )
        self.sessions = {}  # å­˜å‚¨æ¯ä¸ªä¼šè¯çš„ memory
    
    def add_document(self, file_path: str, user_id: int):
        """æ·»åŠ æ–‡æ¡£åˆ°å‘é‡æ•°æ®åº“"""
        # åŠ è½½æ–‡æ¡£
        if file_path.endswith('.pdf'):
            loader = PyPDFLoader(file_path)
        else:
            loader = TextLoader(file_path, encoding='utf-8')
        
        documents = loader.load()
        
        # æ·»åŠ å…ƒæ•°æ®
        for doc in documents:
            doc.metadata['user_id'] = user_id
            doc.metadata['file_path'] = file_path
        
        # åˆ†å—
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        splits = text_splitter.split_documents(documents)
        
        # æ·»åŠ åˆ°å‘é‡æ•°æ®åº“
        self.vectorstore.add_documents(splits)
        
        return {"chunks": len(splits)}
    
    def ask(self, question: str, user_id: int, session_id: str):
        """åŒæ­¥é—®ç­”"""
        # è·å–æˆ–åˆ›å»º memory
        if session_id not in self.sessions:
            self.sessions[session_id] = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                output_key="answer"
            )
        
        # åˆ›å»ºæ£€ç´¢é“¾
        qa_chain = ConversationalRetrievalChain.from_llm(
            llm=self.llm,
            retriever=self.vectorstore.as_retriever(
                search_kwargs={
                    "k": 5,
                    "filter": {"user_id": user_id}  # åªæ£€ç´¢ç”¨æˆ·è‡ªå·±çš„æ–‡æ¡£
                }
            ),
            memory=self.sessions[session_id],
            return_source_documents=True
        )
        
        result = qa_chain({"question": question})
        
        return {
            "answer": result['answer'],
            "sources": [
                {
                    "content": doc.page_content[:200],
                    "metadata": doc.metadata
                }
                for doc in result['source_documents']
            ]
        }
    
    async def ask_stream(
        self,
        question: str,
        user_id: int,
        session_id: str
    ) -> AsyncGenerator[str, None]:
        """å¼‚æ­¥æµå¼é—®ç­”"""
        # æ£€ç´¢ç›¸å…³æ–‡æ¡£
        docs = self.vectorstore.similarity_search(
            question,
            k=5,
            filter={"user_id": user_id}
        )
        
        # æ„å»ºä¸Šä¸‹æ–‡
        context = "\n\n".join([doc.page_content for doc in docs])
        
        # æµå¼ç”Ÿæˆ
        prompt = f"""
        åŸºäºä»¥ä¸‹æ–‡æ¡£å†…å®¹å›ç­”é—®é¢˜ï¼š
        
        {context}
        
        é—®é¢˜ï¼š{question}
        """
        
        stream = self.llm.stream(prompt)
        
        async for chunk in stream:
            if chunk.content:
                yield chunk.content
```

---

#### 1.3 å‰ç«¯å®ç°ï¼ˆReact + TypeScriptï¼‰

```typescript
// frontend/src/App.tsx
import React, { useState, useEffect } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import Login from './pages/Login';
import Dashboard from './pages/Dashboard';
import Chat from './pages/Chat';

function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    const token = localStorage.getItem('access_token');
    setIsAuthenticated(!!token);
  }, []);

  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route
          path="/dashboard"
          element={isAuthenticated ? <Dashboard /> : <Navigate to="/login" />}
        />
        <Route
          path="/chat"
          element={isAuthenticated ? <Chat /> : <Navigate to="/login" />}
        />
        <Route path="/" element={<Navigate to="/dashboard" />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

```typescript
// frontend/src/pages/Chat.tsx
import React, { useState, useEffect, useRef } from 'react';
import { v4 as uuidv4 } from 'uuid';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  sources?: any[];
}

function Chat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [sessionId] = useState(uuidv4());
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    // å»ºç«‹ WebSocket è¿æ¥
    const token = localStorage.getItem('access_token');
    const ws = new WebSocket(
      `ws://localhost:8000/ws/chat/${sessionId}?token=${token}`
    );

    ws.onopen = () => {
      console.log('WebSocket connected');
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'chunk') {
        setMessages((prev) => {
          const lastMessage = prev[prev.length - 1];
          if (lastMessage && lastMessage.role === 'assistant') {
            // è¿½åŠ åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
            return [
              ...prev.slice(0, -1),
              { ...lastMessage, content: lastMessage.content + data.content }
            ];
          } else {
            // åˆ›å»ºæ–°æ¶ˆæ¯
            return [...prev, { role: 'assistant', content: data.content }];
          }
        });
      } else if (data.type === 'done') {
        setIsStreaming(false);
      }
    };

    wsRef.current = ws;

    return () => {
      ws.close();
    };
  }, [sessionId]);

  const sendMessage = () => {
    if (!input.trim() || !wsRef.current || isStreaming) return;

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    setMessages((prev) => [...prev, { role: 'user', content: input }]);

    // å‘é€æ¶ˆæ¯
    wsRef.current.send(input);
    setInput('');
    setIsStreaming(true);
  };

  return (
    <div className="flex flex-col h-screen bg-gray-100">
      {/* å¤´éƒ¨ */}
      <header className="bg-white shadow-sm p-4">
        <h1 className="text-2xl font-bold text-gray-800">AI çŸ¥è¯†åº“åŠ©æ‰‹</h1>
      </header>

      {/* æ¶ˆæ¯åˆ—è¡¨ */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((msg, index) => (
          <div
            key={index}
            className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <div
              className={`max-w-2xl p-4 rounded-lg ${
                msg.role === 'user'
                  ? 'bg-blue-500 text-white'
                  : 'bg-white text-gray-800 shadow'
              }`}
            >
              {msg.content}
              {msg.sources && (
                <div className="mt-2 text-sm opacity-75">
                  æ¥æºï¼š{msg.sources.length} ä¸ªæ–‡æ¡£
                </div>
              )}
            </div>
          </div>
        ))}
      </div>

      {/* è¾“å…¥æ¡† */}
      <div className="bg-white border-t p-4">
        <div className="flex space-x-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
            placeholder="è¾“å…¥ä½ çš„é—®é¢˜..."
            className="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isStreaming}
          />
          <button
            onClick={sendMessage}
            disabled={isStreaming}
            className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:bg-gray-400"
          >
            {isStreaming ? 'ç”Ÿæˆä¸­...' : 'å‘é€'}
          </button>
        </div>
      </div>
    </div>
  );
}

export default Chat;
```

---

### é¡¹ç›® 2ï¼šAI ä»£ç åŠ©æ‰‹

**åŠŸèƒ½**ï¼š
- ä»£ç è§£é‡Š
- ä»£ç ç”Ÿæˆ
- Bug ä¿®å¤å»ºè®®
- ä»£ç å®¡æŸ¥
- æ–‡æ¡£ç”Ÿæˆ

**æŠ€æœ¯æ ˆ**ï¼š
- åç«¯ï¼šFastAPI + LangChain Agents
- å‰ç«¯ï¼šVS Code æ‰©å±• / Web åº”ç”¨
- AIï¼šGPT-4 + Code Llama

---

### é¡¹ç›® 3ï¼šæ™ºèƒ½å®¢æœç³»ç»Ÿ

**åŠŸèƒ½**ï¼š
- è‡ªåŠ¨å›ç­”å¸¸è§é—®é¢˜
- è®¢å•æŸ¥è¯¢
- å·¥å•åˆ›å»º
- æƒ…æ„Ÿåˆ†æ
- äººå·¥å®¢æœè½¬æ¥

**æŠ€æœ¯æ ˆ**ï¼š
- åç«¯ï¼šFastAPI + Multi-Agent
- æ•°æ®åº“ï¼šPostgreSQL + Redis
- å‰ç«¯ï¼šReact + Socket.IO

---

## ğŸš€ éƒ¨ç½²æŒ‡å—

### 1. Docker å®¹å™¨åŒ–

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DATABASE_URL=postgresql://user:password@postgres:5432/dbname
    depends_on:
      - postgres
      - redis
    volumes:
      - ./uploads:/app/uploads
      - ./vectordb:/app/vectordb

  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: dbname
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

volumes:
  postgres_data:
```

---

### 2. CI/CD é…ç½®

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Run tests
        run: |
          pytest

      - name: Build Docker image
        run: |
          docker build -t myapp:latest .

      - name: Push to Docker Hub
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push myapp:latest

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /app
            docker-compose pull
            docker-compose up -d
```

---

## ğŸ“– æ¨èèµ„æº

### éƒ¨ç½²å¹³å°
- **Vercel**ï¼šå‰ç«¯éƒ¨ç½²ï¼ˆæ”¯æŒ Pythonï¼‰
- **Railway**ï¼šå…¨æ ˆéƒ¨ç½²
- **AWS**ï¼šä¼ä¸šçº§éƒ¨ç½²
- **Google Cloud Run**ï¼šå®¹å™¨åŒ–éƒ¨ç½²

### ç›‘æ§ä¸æ—¥å¿—
- **Sentry**ï¼šé”™è¯¯ç›‘æ§
- **LogRocket**ï¼šç”¨æˆ·è¡Œä¸ºåˆ†æ
- **Datadog**ï¼šæ€§èƒ½ç›‘æ§

---

## âœ… å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] èƒ½å¤Ÿè®¾è®¡å®Œæ•´çš„å…¨æ ˆ AI åº”ç”¨æ¶æ„
- [ ] å®ç°å‰åç«¯åˆ†ç¦»çš„è®¤è¯ç³»ç»Ÿ
- [ ] é›†æˆ RAG ç³»ç»Ÿåˆ°ç”Ÿäº§åº”ç”¨
- [ ] å®ç°å®æ—¶æµå¼å“åº”
- [ ] æŒæ¡ Docker å®¹å™¨åŒ–éƒ¨ç½²
- [ ] é…ç½® CI/CD è‡ªåŠ¨åŒ–éƒ¨ç½²
- [ ] å®Œæˆè‡³å°‘ 1 ä¸ªå®Œæ•´çš„å…¨æ ˆ AI é¡¹ç›®

---

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹  [08-å·¥å…·ä¸èµ„æº](./08-å·¥å…·ä¸èµ„æº.md)
